%==== Script of 3DEnVar===
%=== Based in the Paper: "A review of operational methods of variational 
% and ensemble-variational data assimilation" R.N. Bannister
clear all
close all
clc

%==== Parameters====
%===Model Parameters===
load Xreal %True state
tic
n=40; %Number of states
F=8; %External force

%===Observation Parameters===
p_obsersation=0.5;  %Fraction of observabled states
m=round(n*p_obsersation); % Number of observations
sigma=0.01; %Observation error
R=sigma^2*eye(m,m);
inR=(1/sigma^2)*eye(m,m);
H = eye(n,n); 
H = H(randperm(n,m),:);  %Matrix that maps the state space into the observation space

%===Simulation Parameters===
tsim=1000; %Time steps simulation
dt=0.01; %step length

%=== DA parameters===
N=100; % Number of ensemble
r=5; %Localization radius
gam=8; %Gamma observation operator
eps=0.01; %Tolerance rho calculation
q=round(log2(1/eps)); %Number of iterations rho calculation
inner=20; % Number of inner iterations
%====Simulation====
%===Initialization===
xb=zeros(n,tsim,N); % Background State. Dimensions=(states,time,ensemble member)
xa=zeros(n,tsim,N); % Analysis State. Dimensions=(states,time,ensemble member)
Xb=zeros(n,N);


%===Ensemble generation===
x0=rand(n,N); %The ensemble is generated by the initial condition
xb(:,1,:)=x0;
xa=xb;
meanxb=mean(xb(:,1,:),3);
meanxa(:,1)=meanxb;
for i=2:tsim
%===Outer Loop===    
    for Nen=1:N %Propagation in time of all the ensemble members
        [xb(:,i,Nen),t]=Lorenz_96_one_step(1,dt,squeeze(xa(:,i-1,Nen)),F);  
    end
 meanxb=mean(xb(:,i,:),3); %Ensemble mean
 for Nen=1:N
    Xb(:,Nen)= xb(:,i,Nen)-meanxb;  
 end
 Xb=Xb*sqrt(1/(N-1));   
 B=Calculo_B_Cholesky(XB,r); %Estimation of Covariance by Modified Cholesky
 inB=Calculo_inB_Cholesky(XB,r); %Estimation of invserse Covariance by Modified Cholesky
 Bsquare=B^(1/2);
 y(:,i)=H*Xreal(:,i)+sigma*rand(1,1); % Observations
 %==Inner Loop==
     alpha(:,1)=rand(n,1);
     xk(:,1)=meanxb+Bsquare*alpha(:,1);
     Q=H*Bsquare;
     d=y(:,i)-H*xk(:,1);  %Innovation Matriz
     rho=ones(1,inner); %Magnitud of the descend step
     for k=2:inner
         alpha(:,k)= pinv((eye(n,1)+Q'*inR*Q))*(Q'*inR*d);
         %=Calculate of rho=
         a(1)=0;
         b(1)=1;
         for l=1:q
            h=(b(l)-a(l))/4;
            alp1=a(l)+h;
            alp2=a(l)+2*h;
            alp3=a(l)+3*h;
            x1= xk(:,k-1)+alp1*Bsquare*alpha(:,k);
            x2= xk(:,k-1)+alp2*Bsquare*alpha(:,k);
            x3= xk(:,k-1)+alp3*Bsquare*alpha(:,k);
            J1=functional_cost(meanxb,x1,y(:,i),inB,inR,H);
            J2=functional_cost(meanxb,x2,y(:,i),inB,inR,H);
            J3=functional_cost(meanxb,x3,y(:,i),inB,inR,H);
            if (J1<=J2) && (J1<=J3)
                a(l+1)=a(l);
                b(l+1)=alp2;
                rho(1,k)=alp1;
            elseif (J2<=J1) && (J2<=J3)
                a(l+1)=alp1;
                b(l+1)=alp3;
                rho(1,k)=alp2;
            elseif (J3<=J1) && (J3<=J2)
                a(l+1)=alp2;
                b(l+1)=b(l);
                rho(1,k)=alp3;
            end
           
         end
         xk(:,k)=xk(:,k-1)+rho(1,k)*Bsquare*alpha(:,1);
         d=y(:,i)-H*xk(:,k);
     end
     meanxa(:,i)=real(xk(:,end));
%==End Inner Loop==
 for Nen=1:N
     alpha_a=alpha(:,end)+(eye(n,1)+Q'*inR*Q)^(1/2)*rand(n,1);
     xa(:,i,Nen)=real(meanxa(:,i)+rho(1,k)*Bsquare*alpha_a);
 end
 process=i/tsim*100
end

toc
% figure
% Nen=1:N;
% plot(squeeze(xb(5,:,Nen)))