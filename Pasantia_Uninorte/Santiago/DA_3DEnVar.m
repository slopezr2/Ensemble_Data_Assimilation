%==== Script of 3DEnVar===
%=== Based in the Paper: "A review of operational methods of variational 
% and ensemble-variational data assimilation" R.N. Bannister
clear all
close all
clc

%==== Parameters====
%===Model Parameters===
load Xreal %True state
n=40; %Number of states
F=8; %External force

%===Observation Parameters===
p_obsersation=1;  %Fraction of observabled states
m=round(n*p_obsersation); % Number of observations
sigma=0.01; %Observation error
R=sigma^2*eye(m,m);
inR=inv(R);
H = eye(n,n); 
H = H(randperm(n,m),:);  %Matrix that maps the state space into the observation space

%===Simulation Parameters===
tsim=500; %Time steps simulation
dt=0.01; %step length

%=== DA parameters===
N=80; % Number of ensemble
inner=5; %Number of inner steps
tolerance_inner=0.02;
sparse=10; % Sparse of the initial ensemble
add_inflation=0; % Additive inflation

%====Simulation====
%===Initialization===
xb=zeros(n,tsim,N); % Background State. Dimensions=(states,time,ensemble member)
xa=zeros(n,tsim,N); % Analysis State. Dimensions=(states,time,ensemble member)
Xb=zeros(n,N);
Yx=zeros(m,N);
%===Ensemble generation===
x0=sparse*rand(n,N); %The ensemble is generated by the initial condition
xb(:,1,:)=x0;
xa=xb;
for i=2:tsim
    for Nen=1:N %Propagation in time of all the ensemble members
        [xb(:,i,Nen),t]=Lorenz_96_one_step(1,dt,squeeze(xa(:,i-1,Nen)),F);  
    end
 meanxb=mean(xb(:,i,:),3); %Ensemble mean
 meanyb=H*meanxb;  %Model observation based on the ensemble mean
 y(:,i)=H*Xreal(:,i)+sigma*rand(1,1);
 d=y(:,i)-meanyb; %Innovation Matriz
    for Nen=1:N
       Xb(:,Nen)= xb(:,i,Nen)-meanxb;
       Yx(:,Nen)=H*xb(:,i,Nen)-meanyb; %Aproximation of H*M*Xb according with equation (38) 
    end
    Yx=Yx*sqrt(1/(N-1));
    Xb=Xb*sqrt(1/(N-1));
 %===Analysis step===
 %==Inner Loop==
     dx=zeros(N,inner);
     dx(:,1)=rand(N,1);
     xk=zeros(n,inner);
     xk(:,1)=meanxb+Xb*dx(:,1);
     yxk=H*xk(:,1);
     d=(y(:,i)-yxk);  %Innovation Matriz
     k=2;
     norma(1,i)=tolerance_inner;
     flaq=0;
      while norma(k-1,i)>=tolerance_inner && k<inner && flaq<2 
         dx(:,k)= real(pinv(eye(N,1)+Yx'*inR*Yx))*Yx'*inR*d;               
           %=Incremental=
         xk(:,k)=xk(:,k-1)+Xb*dx(:,k);
         yxk=H*xk(:,k);
         d=(y(:,i)-yxk);
         norma(k,i)=norm(Xb*dx(:,k));
         if diff(norma(k-1:k,i))>0 
             flaq=flaq+1;          
         end
         if flaq==2
            dx(:,k)=dx(:,k-1); 
            xk(:,k)=xk(:,k-1);
         end
         k=k+1;
     end
     meanxa(:,i)=(xk(:,k-1));
     yxa(:,i)=H*meanxa(:,i);
%==End Inner Loop==
 
 %=== Here I create the analysis ensemble for the next step, to obtain
%flow dependece ===
 for Nen=1:N
     Xensa=dx(:,k-1)+real(pinv(eye(N,1)+Yx'*inR*Yx))^(1/2)*rand(N,1);
     xa(:,i,Nen)=real(meanxa(:,i)+Xb(:,Nen)*Xensa(Nen))-add_inflation/2+add_inflation*rand(n,1);
 end
   process=i/tsim*100
end


% figure
% Nen=1:N;
% plot(squeeze(xb(5,:,Nen)))