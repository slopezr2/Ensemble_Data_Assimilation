%===MLEF algorithm for the Lorenz 96 Model based in (Zupanski,2005)===
%==Santiago Lopez-Restrepo, Alfonso Mantilla,  Elías D. Niño-Ruiz==

clear all
close all
clc
global C c C_T y i salidas meanxb Xb inR inR_square tipo
%==== Parameters====

%===Simulation Parameters===
tsim=500; %Time steps simulation
dt=0.01; %step length

%===Model Parameters===
load Xreal %True state
L=load('SampleLorenz.mat');
tic
n=40; %Number of states
F=8; %External force

%===Observation Parameters===
p_obsersation=1;  %Fraction of observabled states
m=round(n*p_obsersation); % Number of observations
sigma=0.01; %Observation error
R=sigma^2*eye(m,m);
inR=(1/sigma^2)*eye(m,m);
inR_square=inR^(1/2);
H = eye(n,n); 
salidas=randperm(n,m);
H = H(salidas,:);  %Matrix that maps the state space into the observation space

M=25;
y=zeros(m,tsim);
tipo=7;
frequency=1; % Frequency of observations
tsim=frequency*M;
muestreo=frequency:frequency:tsim;

%=== DA parameters===
N=80; % Number of ensemble
r=1; %Localization radius
global gam
gam=5; %Gamma observation operator

%====Simulation====
%===Initialization===
xb=zeros(n,tsim,N); % Background State. Dimensions=(states,time,ensemble member)
Xb=zeros(n,N);

%===Ensemble generation===
ensemble_sparse=10;
% x0=ensemble_sparse*rand(n,N); %The ensemble is generated by the initial condition
x0=L.XB(:,randperm(length(L.XB),N));
xb(:,1,:)=x0;
xa=xb;
meanxb=mean(xb(:,1,:),3);
Hx = operador(salidas,meanxb,tipo);
XB_time=zeros(n,N,tsim);
meanxa(:,1)=meanxb;
muestra=0;
for i=2:tsim
%===Outer Loop===    
    for Nen=1:N %Propagation in time of all the ensemble members
        [xb(:,i,Nen),t]=Lorenz_96_one_step(1,dt,squeeze(xa(:,i-1,Nen)),F);     
    end
     meanxb=mean(xb(:,i,:),3); %Ensemble mean
     if sum(muestreo==i)   %Validation if there are a observation available
         muestra=muestra+1;
         for Nen=1:N
            Xb(:,Nen)= xb(:,i,Nen)-meanxb;  
         end
         
          Pf=Xb*Xb';
          for Nen=1:N %Propagation in time of all the ensemble members
          %==Calculation Matrix C, see equation (8) and (9)
            c(:,Nen)=inR_square*(operador(salidas,xb(:,i,Nen),tipo)-operador(salidas,meanxb,tipo));
          end
          for i=1:N
             for j=1:N
                C(i,j)=c(:,i)'*c(:,j);  %According with equation (9)
             end
          end
          [V,D] = eig(C);
          C_T=V*((eye(length(D))+D)^(1/2))*V'; %According with equation (10)
      
      
     
     
         %=== Minimization===
         alpha=rand(N,1);
         options = optimoptions('fminunc','Algorithm','quasi-newton','SpecifyObjectiveGradient',true);
         problem.options = options;
         problem.x0 = alpha;
         problem.objective = @costfunction;
         problem.solver = 'fminunc';
         alpha_opt = fminunc(problem);


         %====Analysis===
         meanxa=meanxb+Xb*C_T*alpha_opt;

         for Nen=1:length(C) %Propagation in time of all the ensemble members
            %==Calculation Matrix C, see equation (8) and (9)
            c_opt(:,Nen)=inR_square*(operador(salidas,meanxa + Xb(:,Nen),tipo)-operador(salidas,meanxa,tipo));
         end
         C_opt=c_opt'*c_opt;
         
         
    end %End muestreo 
end